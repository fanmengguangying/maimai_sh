#!/bin/bashBLACK=$'\E[0;1;30;90m'BLINK=$'\E[5m'BLUE=$'\E[0;1;34;94m'BOLD=$'\E[1m'BRIGHT_BLACK=$'\E[0;1;90;90m'BRIGHT_BLUE=$'\E[0;1;94;94m'BRIGHT_CYAN=$'\E[0;1;96;96m'BRIGHT_GREEN=$'\E[0;1;92;92m'BRIGHT_MAGENTA=$'\E[0;1;95;95m'BRIGHT_RED=$'\E[0;1;91;91m'BRIGHT_WHITE=$'\E[0;1;97;97m'BRIGHT_YELLOW=$'\E[0;1;93;93m'CYAN=$'\E[0;1;36;96m'DIM=$'\E[2m'DIRSTACK=()DISPLAY=:2GREEN=$'\E[0;1;32;92m'IFS=$' \t\n'INDEXFILE=/dev/shm/siliconflow_3699/INDEXKEYS=([0]="sk-kgeafucftqwlchmaexrbipypazzxygkbwauczyomytbspdtj" [1]="sk-oqxtgslvqbagabllcxcbwvpyvjiruxsujrkwkjysqlruomck" [2]="sk-mkpzsjdrfgjobjbltxhcacvjskkoddkjuqxcgxfcqaspddbf" [3]="sk-tdmgeizyctniaqpdqyytdlhytovxzyokcwdpsqrdqwxtcvmv" [4]="sk-cwvbgthjppkgyxlqhyclkiaocnkctvxyvtjdcwgxswlesgsk" [5]="sk-akjyltkrsdnqqxoretcxwpqkvyiyyjzdzbnajomjmbwnqsqt" [6]="sk-vhovierpcndwqphouvnxaesqyeihfnwiikkpvzgnvrxrvjbg" [7]="sk-avjsxzgteuewabstgpkswkeetuatadkrazshyzmusnkgorvd" [8]="sk-uxvyxenrcegotckwnsouzawjddehtbxeplarmjtacixvdgnx" [9]="sk-vgesftslxiwwvplcdvfrzonpcsqduwsolosktmhehnamsfkr" [10]="sk-euyywziddaxvrcadrvfzmnqaiiqtwcuktoffpwzseblqmfpu" [11]="sk-hwkkrnnbakbkjjvcxosyxrupfatezoxmvljbemqeukivaldz" [12]="sk-mtwubcyzauzgahpknomzxhftlgkelnvyasgjfqbwmzatyppg" [13]="sk-qdaxlenjjxhbexznsywtwfufcvwbkesdtjlrlrxcleugosbw" [14]="sk-srqlbqtmadxhaxdsmlqoyjmeeefwgmmhmqikropjosatfnby" [15]="sk-qrvlxficcyvssnsyzjjaoizhklytmfeksefyxykhofbmdvag" [16]="sk-jumqbdgohlbasufiqkdusfsmdpekyuruyaglxbvlrklobmdc" [17]="sk-qlyhyrhyxvfadjrpvrjskteyrfdgudegnanfywwmiircwomb" [18]="sk-nisgnathmldeykllaindhyaarcsyeizudptnrdoaiynbxqdy" [19]="sk-kakqxcqznqqbwtktgzhbfdpkkgjimkkhdklvccipckefuvht" [20]="sk-vvybuomhimkdvaqgkqlplqtmrbpuhyrzkzztfwfgoykwsmav" [21]="sk-rafatyieqzxhkyqrufkkifuvomczzmqnsrzdjajcdtgttqgi" [22]="sk-gzbtwmkuwdwovafeigwkvglkkovxuesylshbcajmudgibdgt" [23]="sk-gekothvacgvnpnyqixvbrjnhjvvaflmpeaamfcrurzyvjcgm" [24]="sk-skwrkxsxkxdsawfchhsfmtzjiepgmdgutnysalwxzwettuss" [25]="sk-nkcoktijprsrgmdvawhelauutjkjzeewimticeeqodpnppvc" [26]="sk-esbwyopfgwkmmsnavivnyransypspebblgnuabfjwpwuwwji" [27]="sk-uluqnscctyhwiufadteirgsihbmawgyzlprclgukgvumplrb" [28]="sk-ixakyjhebyslxnsokkdkxfyabqvpakzapnoyszengnggnoba" [29]="sk-puhrkkkjppgkswmbqoxjziuyzuoletotvyocqtywvuvbtiug" [30]="sk-irpaqgxbdnbloxgbhctixsfsrymejvhxnjescdsszcqfdybf")KEY_COUNT=31LOCKFILE=/dev/shm/siliconflow_3699/LOCKLOG_LEVELS=([TRACE]="5" [ERROR]="1" [INFO]="3" [FATAL]="0" [SUCCESS]="3" [WARN]="2" [DEBUG]="4" )MAGENTA=$'\E[0;1;35;95m'NC=$'\E[0m'PID=$$RED=$'\E[0;1;31;91m'REQUEST_TIMES=0REVERSE=$'\E[7m'USING_KEYS=/dev/shm/siliconflow_3699/USING_KEYSWHITE=$'\E[0;1;37;97m'XDG_CONFIG_HOME=/root/.configXMODIFIERS='\@im=fcitx'YELLOW=$'\E[0;1;33;93m'port=3699_auth () {     if [[ "${REQUEST[authorization]}" =~ ^Bearer[[:space:]]+sk- ]]; then        :;    else        printf "HTTP/1.1 401 Unauthorized\r\nContent-Type: text/plain\r\nContent-Length: 22\r\n\r\nAuthorization required.";        exit 0;    fi}acquire_lock () {     local lock_file="${1:-/tmp/process.lock}";    local lock_content="${2:-$$}";    local timeout="${3:-300}";    local interval="${4:-1}";    log.debug "acquire_lock: 开始获取锁，文件: $lock_file, 内容: $lock_content, 超时: $timeout秒" 1>&2;    local start_time=$(date +%s);    local content;    local now;    local max_backoff=5;    local attempt=0;    while true; do        if mkdir "${lock_file}.d" 2> /dev/null; then            echo "$lock_content" > "$lock_file" || log.error "acquire_lock: 无法写入$lock_file" 1>&2;            read -r content < $lock_file;            if [[ "$content" == "$lock_content" ]]; then                log.debug "acquire_lock: 成功获取锁，文件: $lock_file" 1>&2;                return 0;            else                log.trace "acquire_lock: $lock_file繁忙..." 1>&2;                now=$(date +%s);                (( now-start_time>$timeout)) && log.warn "acquire_lock: $lock_file超时$timeout秒" 1>&2 && return 124;                sleep "$interval";            fi;        else            local backoff=$(( (RANDOM % 100) * 2 ** attempt / 100 ));            (( backoff > max_backoff )) && backoff=$max_backoff;            ((attempt++));            sleep "$backoff";        fi;    done}add_invalid_key () {     local index="$1";    local key="$2";    echo "$index $key" >> ./InvalidKeys;    INVALID["$index"]=1}authorization_rebuilt () {     log.debug "authorization_rebuilt: 重建Authorization头，APIKEY: ${APIKEY:0:8}******" 1>&2;    printf "Bearer %s" "$APIKEY"}close_connection () {     log.debug "close_connection: 开始关闭连接，fdin: $1, fdout: $2" 1>&2;    local fdin="${1}";    local fdout="${2}";    local pid_file="/tmp/net_${fdin//\//_}_${fdout//\//_}.pid";    if [[ -f "$pid_file" ]]; then        local net_pid=$(cat "$pid_file");        if ps -p "$net_pid" > /dev/null; then            log.debug "close_connection: 终止进程 $net_pid" 1>&2;            kill "$net_pid" 2> /dev/null;        fi;        rm -f "$pid_file";    fi;    rm -f "${fdin}" "${fdout}" 2> /dev/null;    log.debug "close_connection: 连接关闭完成" 1>&2}connect () {     log.debug "connect: 开始建立连接，fdin: $1, fdout: $2" 1>&2;    local fdin="${1}";    local fdout="${2}";    local host="api.siliconflow.cn";    rm -f "${fdin}" "${fdout}";    mkfifo "${fdin}" "${fdout}" 2> /dev/null;    if command -v openssl > /dev/null 2>&1; then        local port=443;        log.debug "connect: 使用openssl建立SSL连接，主机: $host, 端口: $port" 1>&2;        openssl s_client -connect "${host}:${port}" -quiet < "${fdin}" > "${fdout}" 2> /dev/null &    else        local port=80;        if command -v ncat > /dev/null 2>&1; then            log.debug "connect: 使用ncat建立连接，主机: $host, 端口: $port" 1>&2;            ncat "${host}" "${port}" < "${fdin}" > "${fdout}" 2> /dev/null &        else            if command -v nc > /dev/null 2>&1; then                log.debug "connect: 使用nc建立连接，主机: $host, 端口: $port" 1>&2;                nc "${host}" "${port}" < "${fdin}" > "${fdout}" 2> /dev/null &            else                log.error "connect: 错误 - 未找到openssl、ncat或nc命令" 1>&2;                exit 1;            fi;        fi;    fi;    local net_pid=$!;    echo "$net_pid" > "/tmp/net_${fdin//\//_}_${fdout//\//_}.pid";    sleep 0.2;    log.debug "connect: 连接建立完成，PID: $net_pid, 管道文件: $fdin, $fdout" 1>&2}dashboard_log () {     log.debug "dashboard_log: 开始记录仪表盘日志" 1>&2;    local status_code="${RESPONSE_HEAD[status_code]:-ERR}";    local ts_ms=$(date '+%s%3N');    local day_time=$(date -d @"${ts_ms:0:-3}" '+%F %T');    local preview="${APIKEY:0:8}********";    local inv=${#INVALID[@]};    local left=$((KEY_COUNT - inv));    local ratio=$((left * 100 / KEY_COUNT));    local connection_status="${RESPONSE_HEAD[connection]:-keep-alive}";    END_MS=$(date '+%s%3N');    ELAPSED=$((END_MS - START_MS));    local status_color=$GREEN;    [[ "$status_code" =~ ^[45] ]] && status_color=$RED;    local key_color=$GREEN;    ((left <= 5)) && key_color=$RED;    ((left > 5 && left <= 10)) && key_color=$YELLOW;    local elapsed_color=$GREEN;    ((ELAPSED > 1000)) && elapsed_color=$YELLOW;    ((ELAPSED > 5000)) && elapsed_color=$RED;    local conn_color=$GREEN;    local conn_icon="✓";    if [[ "${connection_status,,}" == "close" ]]; then        conn_color=$RED;        conn_icon="✗";    fi;    local progress_bar="[";    local filled=$((left * 20 / KEY_COUNT));    local empty=$((20 - filled));    progress_bar+="${GREEN}";    for ((i=0; i<filled; i++))    do        progress_bar+="█";    done;    progress_bar+="${RED}";    for ((i=0; i<empty; i++))    do        progress_bar+="░";    done;    progress_bar+="${NC}]";    printf '%s[%s]%s | %sidx=%03d%s | %skey=%s%s | %sinvalid=%d/%d%s | %s%s %d%%%s | %scode=%s%s | %sconn=%s%s%s | %stries=%d%s | %selapsed=%dms%s\n' "$CYAN" "$day_time" "$NC" "$BLUE" "${index:--}" "$NC" "$MAGENTA" "$preview" "$NC" "$YELLOW" "$inv" "$KEY_COUNT" "$NC" "$key_color" "$progress_bar" "$ratio" "$NC" "$status_color" "$status_code" "$NC" "$conn_color" "$conn_icon" "$connection_status" "$NC" "$CYAN" "$REQUEST_TIMES" "$NC" "$elapsed_color" "$ELAPSED" "$NC" >> /dev/shm/siliconflow_${port}/log;    log.debug "dashboard_log: 仪表盘日志记录完成，状态码: $status_code, 耗时: ${ELAPSED}ms, 剩余密钥: $left/$KEY_COUNT" 1>&2}get_key () {     acquire_lock "$LOCKFILE" $$;    while true; do        index=$(next_index);        if (( ${#INVALID[@]} >= KEY_COUNT )); then            log.error "main: 所有API密钥都已失效" 1>&2;            printf "HTTP/1.1 503 Service Unavailable\r\nContent-Type: text/plain\r\nContent-Length: 23\r\n\r\nAll API keys invalid.";            release_lock "$LOCKFILE" $$;            exit 1;        fi;        [[ -z "${INVALID[$index]}" ]] && break;        log.debug "main: 跳过无效密钥索引: $index" 1>&2;    done;    APIKEY="${KEYS[$index]}";    release_lock "$LOCKFILE" $$}host_rebuilt () {     log.debug "host_rebuilt: 重建Host头" 1>&2;    printf "api.siliconflow.cn"}init_invalid_keys () {     while read -r line; do        [[ "$line" =~ ^[0-9]+ ]] && INVALID["${line%% *}"]=1;    done < ./InvalidKeys 2> /dev/null}log () {     local LOG_TYPE="${1:-INFO}";    local LOG_MSG="${2:-}";    local LOG_TIME=$(date +"%F %T");    if [[ -z "${LOG_LEVELS[$LOG_TYPE]}" ]]; then        LOG_MSG="$LOG_TYPE $LOG_MSG";        LOG_TYPE="INFO";    fi;    case "$LOG_TYPE" in         FATAL)            LOG_COLOR=$RED        ;;        ERROR)            LOG_COLOR=$RED        ;;        WARN)            LOG_COLOR=$YELLOW        ;;        INFO)            LOG_COLOR=$WHITE        ;;        SUCCESS)            LOG_COLOR=$GREEN        ;;        DEBUG)            LOG_COLOR=$PURPLE        ;;        TRACE)            LOG_COLOR=$CYAN        ;;        *)            LOG_COLOR=$WHITE        ;;    esac;    (( ${LOG_LEVELS[$LOG_TYPE]} <= ${LOG_LEVELS[$LOG_LEVEL]} )) && printf '%s' "${LOG_COLOR}[${LOG_TIME}] [${LOG_TYPE}] ${LOG_MSG}${NC}"''}log.debug () {     log DEBUG "$@"}log.error () {     log ERROR "$@"}log.fatal () {     log FATAL "$@"}log.info () {     log INFO "$@"}log.success () {     log SUCCESS "$@"}log.trace () {     log TRACE "$@"}log.warn () {     log WARN "$@"}main () {     trap dashboard_log EXIT;    log.debug "main: 开始处理请求，请求次数: $REQUEST_TIMES" 1>&2;    ((REQUEST_TIMES++));    if (( REQUEST_TIMES == 1 )); then        log.debug "main: 首次请求，解析HTTP头" 1>&2;        process_http_headers "REQUEST";        _auth;        if [[ -n "${REQUEST[content-length]}" ]]; then            body="$(dd bs=1 count="${REQUEST[content-length]}" 2> /dev/null | jq -c . 2> /dev/null || cat)";            REQUEST['content-length']="$(printf '%s' "$body" | wc -c)";            log.debug "main: 解析请求体，长度: ${REQUEST[content-length]}" 1>&2;        else            body="";            log.debug "main: 无请求体" 1>&2;        fi;    fi;    turn2siliconflow;    log.debug "main: 请求处理完成" 1>&2}next_index () {     log.debug "next_index: 开始获取下一个索引" 1>&2;    local idx;    [[ -f "$INDEXFILE" ]] && read -r idx < "$INDEXFILE" || idx=0;    ((idx >= KEY_COUNT)) && idx=0;    echo $((idx + 1)) > "$INDEXFILE";    log.debug "next_index: 获取到索引: $idx, 下一个索引: $((idx + 1))" 1>&2;    echo "$idx"}process_http_headers () {     log.debug "process_http_headers: 开始解析HTTP头" 1>&2;    local -n _headers_ref=$1;    _headers_ref=();    IFS='' read -r line;    IFS=' ' read -ra parts <<< "$line";    case "${parts[0]}" in         GET | POST | PUT | DELETE | HEAD | OPTIONS | PATCH | TRACE | CONNECT)            _headers_ref[method]="${parts[0]}";            _headers_ref[path]="${parts[1]}";            _headers_ref[http_version]="${parts[2]}";            log.debug "process_http_headers: 请求行 - 方法: ${parts[0]}, 路径: ${parts[1]}, 版本: ${parts[2]}" 1>&2        ;;        'HTTP/'*)            _headers_ref[http_version]="${parts[0]}";            _headers_ref[status_code]="${parts[1]}";            _headers_ref[status_text]="${parts[*]:2}";            log.debug "process_http_headers: 响应行 - 版本: ${parts[0]}, 状态码: ${parts[1]}, 状态文本: ${parts[*]:2}" 1>&2        ;;    esac;    while IFS='' read -r line; do        [[ -z "$line" ]] && break;        local header_name="${line%%: *}";        local header_value="${line#*: }";        _headers_ref["${header_name,,}"]="$header_value";        log.trace "process_http_headers: 头字段 - ${header_name}: ${header_value}" 1>&2;    done;    log.debug "process_http_headers: 完成解析，共 ${#_headers_ref[@]} 个头字段" 1>&2}read_response () {     log.debug "read_response: 开始读取响应，流模式: $1" 1>&2;    local stream_mode="${1:-false}";    local headers_ref_name="${2:-RESPONSE_HEAD}";    local -n _headers_ref=$headers_ref_name;    if [[ "$stream_mode" == "true" ]]; then        if [[ "${_headers_ref[transfer-encoding]}" == "chunked" ]]; then            log.debug "read_response: 使用分块传输编码读取流式响应" 1>&2;            while IFS='' read -r chunk_size_hex; do                chunk_size=$((16#${chunk_size_hex}));                [[ $chunk_size -eq 0 ]] && break;                dd bs=1 count="$chunk_size" 2> /dev/null;                read -r _;            done;        else            cat;        fi;    else        if [[ -n "${_headers_ref[content-length]}" ]]; then            log.debug "read_response: 使用Content-Length读取响应，长度: ${_headers_ref[content-length]}" 1>&2;            dd bs=1 count="${_headers_ref[content-length]}" 2> /dev/null;        else            if [[ "${_headers_ref[transfer-encoding]}" == "chunked" ]]; then                log.debug "read_response: 使用分块传输编码读取响应" 1>&2;                local response_body="";                while IFS='' read -r chunk_size_hex; do                    chunk_size=$((16#${chunk_size_hex}));                    [[ $chunk_size -eq 0 ]] && break;                    IFS= read -r -N "$chunk_size" chunk_data;                    response_body+="$chunk_data";                    read -r _;                done;                printf "%s" "$response_body";            else                log.debug "read_response: 使用默认方式读取响应" 1>&2;                cat;            fi;        fi;    fi;    log.debug "read_response: 响应读取完成" 1>&2}read_shared_memory () {     if [[ ! -f "/dev/shm/siliconflow_${port}/key_count" || ! -f "/dev/shm/siliconflow_${port}/ALLKEYS" ]]; then        echo "Error: Shared memory files not found. Please run the setup script." 1>&2;        exit 1;    fi;    read -r KEY_COUNT < /dev/shm/siliconflow_${port}/key_count;    mapfile -t KEYS < /dev/shm/siliconflow_${port}/ALLKEYS}rebuild_http_headers () {     log.debug "rebuild_http_headers: 开始重建HTTP头" 1>&2;    local -n _headers_ref=$1;    if [[ -n "${_headers_ref[method]}" ]]; then        printf "%s %s %s\r\n" "${_headers_ref[method]}" "${_headers_ref[path]}" "${_headers_ref[http_version]}";        log.debug "rebuild_http_headers: 重建请求行 - ${_headers_ref[method]} ${_headers_ref[path]} ${_headers_ref[http_version]}" 1>&2;    else        if [[ -n "${_headers_ref[http_version]}" ]]; then            printf "%s %s %s\r\n" "${_headers_ref[http_version]}" "${_headers_ref[status_code]}" "${_headers_ref[status_text]}";            log.debug "rebuild_http_headers: 重建响应行 - ${_headers_ref[http_version]} ${_headers_ref[status_code]} ${_headers_ref[status_text]}" 1>&2;        fi;    fi;    for header_name in "${!_headers_ref[@]}";    do        [[ "$header_name" =~ ^(method|path|http_version|status_code|status_text)$ ]] && continue;        local header_value="${_headers_ref[$header_name]}";        local rebuild_function="${header_name}_rebuilt";        if declare -f "$rebuild_function" > /dev/null; then            log.debug "rebuild_http_headers: 调用重建函数: $rebuild_function" 1>&2;            header_value=$($rebuild_function);        fi;        printf "%s: %s\r\n" "$header_name" "$header_value";        log.debug "rebuild_http_headers: 重建头字段 - ${header_name}: ${header_value}" 1>&2;    done;    printf "\r\n";    log.debug "rebuild_http_headers: 完成重建HTTP头" 1>&2}release_lock () {     local lock_file="${1:-/tmp/process.lock}";    local lock_content="${2:-$$}";    log.debug "release_lock: 开始释放锁，文件: $lock_file, 内容: $lock_content" 1>&2;    if [[ -f "$lock_file" ]]; then        local current_content;        read -r current_content < $lock_file;        if [[ "$current_content" == "$lock_content" ]]; then            rm -f "${lock_file}" 2> /dev/null;            rm -r "${lock_file}.d" 2> /dev/null;            log.debug "release_lock: 成功释放锁，文件: $lock_file" 1>&2;        else            log.warn "release_lock: 锁内容不匹配，不释放锁，文件: $lock_file" 1>&2;            return 1;        fi;    else        log.debug "release_lock: 锁文件不存在，文件: $lock_file" 1>&2;    fi}send_request () {     log.debug "send_request: 开始发送请求，fdin: $1, 头数组: $2, 数据长度: $(wc -c <<< $3)" 1>&2;    local fdin="$1";    local headers_array_name="$2";    local body_data="${3:-}";    rebuild_http_headers "$headers_array_name" > "${fdin}";    if [[ -n "$body_data" ]]; then        printf "%s" "$body_data" > "${fdin}";    fi;    log.debug "send_request: 请求发送完成" 1>&2}turn2siliconflow () {     log.debug "turn2siliconflow: 开始转发请求到SiliconFlow" 1>&2;    local fd;    local connection_lock;    local fdin;    local fdout;    local lock_acquired=false;    for fd in {1..5};    do        connection_lock="/dev/shm/siliconflow_${port}/connections/${APIKEY}_${fd}.LOCK";        fdin="/dev/shm/siliconflow_${port}/connections/${APIKEY}_${fd}_in";        fdout="/dev/shm/siliconflow_${port}/connections/${APIKEY}_${fd}_out";        log.debug "turn2siliconflow: 尝试获取连接 $fd 的锁" 1>&2;        if acquire_lock "$connection_lock" $$ 0 0.01; then            log.debug "turn2siliconflow: 成功获取连接 $fd 的锁" 1>&2;            lock_acquired=true;            break;        else            local lock_pid;            lock_pid=$(cat "$connection_lock" 2> /dev/null);            if [[ -n "$lock_pid" ]]; then                if ! kill -0 "$lock_pid" 2> /dev/null; then                    log.debug "连接 $fd 的锁进程 $lock_pid 不存在，清理并重新获取" 1>&2;                    rm -rf "$connection_lock" "$fdin" "$fdout" "${connection_lock}.d";                    if acquire_lock "$connection_lock" $$ 0 0.01; then                        log.debug "turn2siliconflow: 成功获取清理后的连接 $fd 的锁" 1>&2;                        lock_acquired=true;                        break;                    fi;                fi;            else                log.debug "连接 $fd 的锁文件为空，清理" 1>&2;                rm -f "$connection_lock" "$fdin" "$fdout";            fi;        fi;    done;    if [[ $lock_acquired != true ]]; then        log.error "turn2siliconflow: 无法获取任何连接锁" 1>&2;        return 1;    fi;    log.debug "turn2siliconflow: 使用连接 $fd，输入: $fdin, 输出: $fdout" 1>&2;    if [[ ! -p "$fdin" || ! -p "$fdout" ]]; then        log.debug "turn2siliconflow: 连接管道不存在，创建连接" 1>&2;        if ! connect "$fdin" "$fdout"; then            log.error "turn2siliconflow: 创建连接失败" 1>&2;            release_lock "$connection_lock" $$;            return 1;        fi;    fi;    REQUEST[host]="api.siliconflow.cn";    if ! send_request "$fdin" "REQUEST" "$body"; then        log.error "turn2siliconflow: 发送请求失败" 1>&2;        release_lock "$connection_lock" $$;        return 1;    fi;    local response_body;    if ! process_http_headers "RESPONSE_HEAD" < "$fdout"; then        log.error "turn2siliconflow: 处理响应头失败" 1>&2;        release_lock "$connection_lock" $$;        return 1;    fi;    response_body=$(read_response "false" "RESPONSE_HEAD" < "$fdout");    release_lock "$connection_lock" $$;    if [[ ${RESPONSE_HEAD["connection"]} == "close" ]]; then        log.debug "turn2siliconflow: 连接被标记为关闭，清理连接 $fd" 1>&2;        close_connection "$fdin" "$fdout";        rm -f "$connection_lock";    fi;    local status="${RESPONSE_HEAD[status_code]}";    log.debug "turn2siliconflow: 收到响应，状态码: $status" 1>&2;    case $status in         401 | 403)            log.debug "turn2siliconflow: 处理认证错误，状态码: $status" 1>&2;            if echo "$response_body" | jq -e '.code == 30011' > /dev/null 2>&1; then                log.debug "turn2siliconflow: 检测到模型降级错误，尝试降级模型" 1>&2;                downgraded="$(echo "$body" | jq -c '            .model |= (                if startswith("Pro/") then .[4:] else . end |                if startswith("/") then .[1:] else . end            )            ')";                body="$downgraded";                log.debug "turn2siliconflow: 模型降级完成，重新调用main函数" 1>&2;                main <<< "$(rebuild_http_headers "REQUEST")$body";                return $?;            else                log.warn "turn2siliconflow: API密钥无效，添加到无效列表，索引: $index" 1>&2;                add_invalid_key "$index" "${KEYS[$index]}";            fi        ;;        429 | 400 | 413 | 500 | 502 | 503 | 504)            log.debug "turn2siliconflow: 处理状态码 $status" 1>&2;            if [[ $status == 400 ]]; then                if echo "$body" | jq -e 'has("enable_thinking")' > /dev/null 2>&1; then                    log.debug "turn2siliconflow: 检测到enable_thinking参数，尝试移除" 1>&2;                    downgraded="$(echo "$body" | jq -c 'del(.enable_thinking)')";                    body="$downgraded";                    log.debug "turn2siliconflow: 参数移除完成，重新调用main函数" 1>&2;                    main <<< "$(rebuild_http_headers "REQUEST")$body";                    return $?;                fi;            else                if [[ $status == 429 ]]; then                    ((TIMES_429++));                    using_keys=($(ls $USING_KEYS));                    if [[ -z "${using_keys[TIMES_429]}" ]]; then                        APIKEY_OLD=$APIKEY;                        while {                             get_key && [[ ! "$APIKEY_OLD" == "$APIKEY" ]]                        }; do                            :;                        done;                        echo "$APIKEY" > "$USING_KEYS/$APIKEY";                    fi;                fi;            fi        ;;    esac;    rebuild_http_headers "RESPONSE_HEAD";    printf "%s" "$response_body";    log.debug "turn2siliconflow: 转发完成，响应体长度: ${#response_body}" 1>&2}main