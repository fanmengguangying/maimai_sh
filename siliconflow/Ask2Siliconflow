#!/bin/bash
# curl -v http://localhost:3699/v1/chat/completions \                                                                                                                                           ─╯ 
#   -H "Content-Type: application/json" \
#   -H "Authorization: Bearer sk-abcd" \
#   -d $(echo '{
#         "model": "Pro/moonshotai/Kimi-K2-Instruct-0905",
#         "messages": [{"role": "user", "content": "你好，我来自bash客户端发来的请求！"}],
#         "stream": false,
#         "max_tokens": 50,
#         "enable_thinking": false }'|jq -c .)
# ---------- 0. 路径常量 ----------
LOCKFILE="/dev/shm/2Siliconflow/LOCK"
INDEXFILE="/dev/shm/2Siliconflow/INDEX"
PID=$$
START_MS="$(date '+%s%3N')"
REQUEST_TIMES=0
# ---------- 1. 加锁 / 解锁 ----------
acquire_lock() {
    while true; do
        if [[ ! -f "$LOCKFILE" ]]; then
            echo "$PID" >"$LOCKFILE"
        else
            first=$(cat  "$LOCKFILE" 2>/dev/null|head -n1 2>/dev/null || echo "")
            [[ "$first" == "$PID" ]] && break
            echo "$PID" >>"$LOCKFILE"
            sleep 0.01
        fi
    done
}
release_lock() { rm -f "$LOCKFILE"; }

# ---------- 2. 读共享内存 ----------
read -r KEY_COUNT </dev/shm/2Siliconflow/key_count
mapfile -t KEYS </dev/shm/2Siliconflow/ALLKEYS

# ---------- 3. 失效索引表 ----------
declare -A INVALID
while read -r line; do
    [[ "$line" =~ ^[0-9]+ ]] && INVALID["${line%% *}"]=1
done </dev/shm/2Siliconflow/InvalidKeys 2>/dev/null

# ---------- 4. 原子取下一个有效下标 ----------
next_index() {
    local idx
    [[ -f "$INDEXFILE" ]] && read -r idx <"$INDEXFILE" || idx=0
    ((idx >= KEY_COUNT)) && idx=0
    echo $((idx + 1)) >"$INDEXFILE"
    echo "$idx"
}
acquire_lock
while true; do
    index=$(next_index)
    [[ -z "${INVALID[$index]}" ]] && break
done
APIKEY="${KEYS[$index]}"
release_lock

# ---------- 5. 重建 Authorization ----------
Authorization_rebuilt() { printf "Bearer %s" "$APIKEY"; }
Host_rebuilt() { printf "api.siliconflow.cn"; }
# User-Agent_rebuilt(){ printf "curl/7.88.1"; }

# ---------- 6. HTTP 解析与重建 ----------
declare -A REQUEST
declare -A RESPONSE_HEAD
process_head() {
    local arr_name="${1:-REQUEST}"
    local -n _REQ=$arr_name >/dev/null 2>&1
    while IFS=$'\r' read -r line; do
        # printf 'proc:%s\n' "$line" >&2
        [[ -z "$line" ]] && break
        IFS=' ' read -ra arr <<<"$line"
        case "${arr[0]}" in
        GET | POST | PUT | DELETE | HEAD | OPTIONS | PATCH | TRACE | CONNECT)
            [[ "${arr[0]}" != "POST" ]] && echo '不被支持的请求！' >&2 && exit 127
            _REQ[METHOD]="${arr[0]}"
            _REQ[PATH]="${arr[1]}"
            _REQ[HTTP_VERSION]="${arr[2]}"
            ;;
        'HTTP/'*)
            _REQ[HTTP_VERSION]="${arr[0]}"
            _REQ[STATUS_CODE]="${arr[1]}"
            _REQ[STATUS_TEXT]="${arr[*]:2}"
            ;;
        *) _REQ["${arr[0]%:}"]="${line#*: }" ;;
        esac
    done
}

rebuild_head() {
    # 默认仍用 REQUEST 数组，也可通过第一个参数指定别的关联数组名
    local arr_name="${1:-REQUEST}"
    local -n _REQ=$arr_name >/dev/null 2>&1

    local h

    # 1. 根据解析时到底存的是“请求行”还是“状态行”决定第一行格式
    if [[ -n ${_REQ[METHOD]} ]]; then
        # 请求报文
        h="${_REQ[METHOD]} ${_REQ[PATH]} ${_REQ[HTTP_VERSION]}\r\n"
    elif [[ -n ${_REQ[HTTP_VERSION]} ]]; then
        # 响应报文
        h="${_REQ[HTTP_VERSION]} ${_REQ[STATUS_CODE]} ${_REQ[STATUS_TEXT]}\r\n"
    else
        h="" # 兜底，行为与原脚本一致：空行开头
    fi

    # 2. 重建普通头部（跳过五项内置键，其余按哈希表遍历顺序）
    for k in "${!_REQ[@]}"; do
        [[ "$k" =~ ^(METHOD|PATH|HTTP_VERSION|STATUS_CODE|STATUS_TEXT)$ ]] && continue
        local v=${_REQ[$k]}

        # 如果用户给某头部定义了名为 "${k}_rebuilt" 的函数，就调用它拿新值
        local fn="${k}_rebuilt"
        declare -f "$fn" >/dev/null && v=$($fn)

        h+="$k: $v\r\n"
    done

    # 3. 结尾空行
    h+="\r\n"

    # 4. 原样输出，不带额外换行
    printf "%s" "$h"
}
# ---------- 7. 转发 ----------
turn2siliconflow() {
    exec 3<>/dev/tcp/api.siliconflow.cn/80

    # 发请求
    echo -en "$1" >&3
    printf '%s' "$2" >&3

    # 读响应
    process_head 'RESPONSE_HEAD' <&3
    response_head=$(rebuild_head 'RESPONSE_HEAD')
    response=$(dd bs=1 count="${RESPONSE_HEAD[Content-Length]}" 2>/dev/null <&3)$'\r\n\r\n'

    exec 3<&-; exec 3>&-

    status=${RESPONSE_HEAD[STATUS_CODE]}
    case $status in
    401|403)
    # set -x
        # 401 是 Unauthorized，403 是 Forbidden
        # 30011 模型前缀错误 → 降级
        if jq -e '.code == 30011' <<<"$response" >/dev/null 2>&1; then
            # 清理模型名前缀的 '/' 和 'Pro/'
            downgraded="$(jq -c '
            .model |= (
                if startswith("Pro/") then .[4:] else . end |
                if startswith("/") then .[1:] else . end
            )
            ' <<<"$2")"
            # sleep 5
            { main; } <<<"$(echo -en "$1";printf '%s' "$downgraded")"
            return $?
        else
            echo "$index ${KEYS[$index]}" >>/dev/shm/2Siliconflow/InvalidKeys
        fi
        ;;
    429|400|413|500|502|503|504)
        if [[ $status == 400 ]]; then
            # 请求体里带了 enable_thinking → 删掉再重试
            if jq -e 'has("enable_thinking")' <<<"$2" >/dev/null 2>&1; then
                downgraded="$(jq -c 'del(.enable_thinking)' <<<"$2")"
                { main; } <<<"$(echo -en "$1";printf '%s' "$downgraded")"
                return $?
            fi
        fi
    ;;
    esac

    echo -en "$response_head"
    echo -n "$response"
}

# ---------- 仪表盘函数 ----------
dashboard_log() {
    # 真毫秒级时间戳
    local ts_ms=$(date '+%s%3N')
    local day_time=$(date -d @"${ts_ms:0:-3}" '+%F %T')
    local preview="${APIKEY:0:8}********"
    local inv=${#INVALID[@]}
    local left=$((KEY_COUNT - inv))
    END_MS=$(date '+%s%3N')
    ELAPSED=$((END_MS - START_MS))

    # 彩色阈值
    local color=$'\033[32m'                         # 默认绿色
    ((left <= 5)) && color=$'\033[31m'              # 红
    ((left > 5 && left <= 10)) && color=$'\033[33m' # 黄

    # 表格化输出（空格对齐，方便 tail -f）
    printf '%s[%s]| idx=%03d | key=%s | invalid=%03d | left=%03d | code=%s | tries=%s | elapsed=%sms '$'\033[0m''\n' \
        "$color" "$day_time" "$index" "$preview" "$inv" "$left" "$status" "$REQUEST_TIMES" "$ELAPSED" \
        >>/dev/shm/2Siliconflow/log
}

_auth() {
    if [[ "${REQUEST[Authorization]}" =~ ^Bearer[[:space:]]+sk- ]]; then
        :
    else
        exit 0 # 静默退出，不响应，防止端口被扫描
    fi
}

# ---------- 8. 主程序 ----------
main() {
    ((REQUEST_TIMES++))
    process_head 'REQUEST'
    _auth # 简单鉴权
    # 原样读取 body
    body="$(dd bs=1 count="${REQUEST[Content-Length]}" 2>/dev/null | jq -c .)"
    REQUEST['Content-Length']="$(printf '%s' "$body" | wc -c)"
    # 直接转发
    turn2siliconflow "$(rebuild_head)" "$body"$'\r\n' # 重建head
}

main
dashboard_log